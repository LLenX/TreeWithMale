#ifndef TREEWITHMALE_FAMILYTREE_HPP_
#define TREEWITHMALE_FAMILYTREE_HPP_

#include "AllPerson.hpp"
#include <unordered_map>

/**
 * simply a manage of people of the whole family
 */
class FamilyTree {
  public:
    /**
     * error generated when doing operation to the family tree or person inside
     */
    enum class Error {
        /**
         * the type of selected person doesn't support certain operation
         */
            INVALID_TYPE,

        /**
         * the query result doen't exist
         */
            RESULT_NOT_FOUND,

        /**
         * doing operation on a person before select one
         */
            EMPTY_SELECTION,

        /**
         * a person already exist when need to create another one
         */
            PERSON_CONFILCT,

        /**
         * try to have baby before marry, marry before divorce etc... :)
         */
            WRONG_LOGIC
    };

    /**
     * get the error generated by last operation that generates error,
     * if this function is called when no error is generated, result is
     * uncertain
     * @return the error
     */
    Error GetError() const;

    /**
     * create an ancestor for the family tree and select him if success, do
     * nothing if fail
     * @param info the information of the person
     * @return the pointer pointing to the ancestor if there is no ancestor,
     *         nullptr otherwise
     */
    std::shared_ptr<Person> CreateAncestor(const Person::Info &info);

    /**
     * select a person by id, if person is not found, return nullptr an set
     * error code to RESULT_NOT_FOUND
     * @param id the unique id used to index the person
     * @return the pointer to the corresponding person, nullptr if not found
     */
    std::shared_ptr<Person> SelectPerson(const std::string &id);

    /**
     * get mother of the selected person, doesn't change the selected person
     * if no person is selected, EMPTY_SELECTION is set
     * if the selected person is the ancestor, RESULT_NOT_FOUND is set
     * if the selected person is not BloodRelation, INVALID_TYPE is set
     * @return pointer pointing to the mother of the selected person, nullptr
     *         if one of the error above occurs
     */
    std::shared_ptr<const Wife> GetMother();

    /**
     * get father of the selected person, doesn't change the selected person
     * if no person is selected, EMPTY_SELECTION is set
     * if the selected person is the ancestor, RESULT_NOT_FOUND is set
     * if the selected person is not BloodRelation, INVALID_TYPE is set
     * @return pointer pointing to the father of the selected person, nullptr
     *         if one of the error above occurs
     */
    std::shared_ptr<const Male> GetFather();

    /**
     * get the couple of the selected person, doesn't change the selected person
     * if no person is selected, EMPTY_SELECTION is set
     * if the selected person is not Parent, INVALID_TYPE is set
     * @return pointer pointing to the couple of the selected person, nullptr
     *         if one of the error above occurs
     */
    std::shared_ptr<const Parent> GetCouple();

    /**
     * get siblings of the selected person, doesn't change the selected person
     * if no person is selected, EMPTY_SELECTION is set
     * if the selected person is not BloodRelation, INVALID_TYPE is set
     * @return pointer pointing to the Vector of siblings of the selected person
     *         nullptr if one of the error above occurs
     */
    std::shared_ptr<const Person::Vector<BloodRelation>> GetSiblings();

    /**
     * get children of the selected person, doesn't change the selected person
     * if no person is selected, EMPTY_SELECTION is set
     * if the selected person is not parent, INVALID_TYPE is set
     * @return pointer pointing to the mother of the selected person, nullptr
     *         if one of the error above occurs
     */
    std::shared_ptr<const Person::Vector<BloodRelation>> GetChildren();

    /**
     * the selected person give birth to a baby and return the baby if success
     * if no person is selected, EMPTY_SELECTION is set
     * if selected person if not parent, INVALID_TYPE is set
     * if the id in info is taken, PERSON_CONFLICT is set
     * if the man doesn't even get married, WRONG_LOGIC is set
     * @param info the information of the baby
     * @param gender the gender of the baby
     * @return the pointer pointing to the baby if success, nullptr if fail
     */
    std::shared_ptr<BloodRelation>
    GiveBirthTo(const Person::Info &info, Person::PersonGender gender);

    /**
     * the selected person marry to a wife and return her if success
     * if no person is selected, EMPTY_SELECTION is set
     * if selected person is not Male, INVALID_TYPE is set
     * if the id in info is taken, PERSON_CONFLICT is set
     * if the man has been married already, WRONG_LOGIC is set
     * @param info the infomation of the wife
     * @return the pointer pointing to the wife if success, nullptr if fail
     */
    std::shared_ptr<Wife> Marry(const Person::Info &info);

    /**
     * the selected person divorce his/her couple
     * if no person is selected, EMPTY_SELECTION is set
     * if selected person is not parent, INVALID_TYPE is set
     * if the person doesn't even get married, WRONG_LOGIC is set
     * @return true if success, false if one of the situations above occurs
     */
    bool Divorce();

    /**
     * kill the selected person
     * if no person is selectied, EMPTY_SELECTION is set
     * if selected person is dead already, WRONG_LOGIC is set
     * @return true if the person's killed successfully, false if fail
     */
    bool Die();

  private:
    /**
     * set error to the corresponding error
     * @param error the error to set
     */
    void SetError(Error error);

    /**
     * check whether a person is selected, if not
     * set error code to EMPTY_SELECTION
     * @return true if a person is selected, false if not
     */
    bool CheckPersonSelected();

    /**
     * helper function to get family member, check types during getting
     * @param getter the getter for the selected person
     * @return the result pointer, nullptr if error happened
     */
    template<typename Result, typename Person>
    std::shared_ptr<const Result>
    GetFamilyMember(std::shared_ptr<Result> (Person::*getter)() const) {
        if (not CheckPersonSelected()) {
            return nullptr;
        }

        auto casted_person = CheckAndCast<Person>(selected_person_);
        if (not casted_person) {
            return nullptr;
        }

        return GetAndCheckExist(casted_person, getter);
    }

    /**
     * check whether the pointer of current type can be dynamically convert to
     * GuessType, if conversion fail, set INVALID_TYPE
     * @param person the person to check
     * @return the result of the cast if success, nullptr if fail
     */
    template<typename GuessType, typename CurrentType>
    std::shared_ptr<GuessType> CheckAndCast(
        std::shared_ptr<CurrentType> person) {
        auto result_ptr = std::dynamic_pointer_cast<GuessType>(person);
        if (not result_ptr) {
            SetError(Error::INVALID_TYPE);
        }
        return result_ptr;
    }

    /**
     * helper function to invoke the getter of a person and check whether the
     * result is nullptr, if it is, set RESULT_NOT_FOUND
     * @param person the person do the getter
     * @param getter the getter method for the person
     * @return the result of getter
     */
    template<typename Result, typename Person>
    std::shared_ptr<const Result> GetAndCheckExist(
        std::shared_ptr<Person> person,
        std::shared_ptr<Result> (Person::*getter)() const) {
        std::shared_ptr<Result> result_ptr = ((*person).*getter)();
        if (not result_ptr) {
            SetError(Error::RESULT_NOT_FOUND);
        }
        return result_ptr;
    }

    /**
     * helper function to check if the id exists in the record, if so, return
     * true and set PERSON_CONFLICT
     * @param id the id to check
     * @return true if the id conflicts with other person, false if ok
     */
    bool CheckConflictId(const std::string &id);

    /**
     * the error generated by operations
     */
    Error error_;

    /**
     * ancestor of the whole family
     */
    std::shared_ptr<Person> ancestor_;

    /**
     * record all people to ensure the search efficient
     */
    std::unordered_map<std::string, std::shared_ptr<Person>> person_record_;

    /**
     * current selected person
     */
    std::shared_ptr<Person> selected_person_;
};

#endif //TREEWITHMALE_FAMILYTREE_HPP_
